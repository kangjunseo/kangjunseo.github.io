---
layout: single
title: "<C++> 백준 1011번 `Fly me to the Alpha Centauri` 풀이"
---

[TOC](#목차)

1. [간단한 풀이 흐름](#1-간단한-풀이-흐름)

2. [코드](#2-코드)



## 아직 미완성이고, 풀이 직후라 풀이 흐름과 코드만 남기겠습니다.

처음 접해본 백준 골드 문제였는데, 생각보다 괜찮은(?) 사고방식으로 빠르게 푼 거 같아서 공유합니다.

[백준 1011번](https://www.acmicpc.net/problem/1011 "백준 1011번")

# 간단한 풀이 흐름

일단 횟수를 최소한으로 줄여야하는 문제이기 때문에, Best case는 계속 증가하다 중간 지점에서 최댓값을
찍고, 가장 끝에서 1로 마무리하는 케이스가 있습니다. 그런데 이런식으로 생각하다 보니 굳이 시작부터 끝까지
순서대로 생각할 필요가 없다고 생각했습니다. 그냥 양쪽 끝부터 하나씩 처리하다 마지막에 최대값을 처리하는
그런 방식으로 접근했어요.

그래서 만약 주어진 거리가 `19`라면, 처음에는 `1`만큼 두번 거리를 감소시키고, 그다음 `2`만큼 두번, `3`만큼 두번
감소시키다 보면 증감 시킬양이 남은 거리보다 커지는 순간이 오게 되고 그 때 'break' 하게 되면 되는 것이죠.

근데 이런 식의 사고는 실질적으로는 하나 문제가 발생하게 되는데, `1` `1` `2` `2` `3` `3` ... `15` `15` 이렇게 두개 씩 감소
시키는 것 까지는 괜찮은데, 만약 남은거리가 감자기 `4` 이렇게 작아버리면 어떻게 하냐는 의문점이 생기죠.

하지만 우리는 계속 이동가능한 최대거리를 이동해왔기 때문에, 그리고 그 양을 점진적으로 늘려왔기 때문에, 이 갭은
이제까지 이동했던 거리들을 조금씩 감소하는것 만으로도 충분히 컨트롤 할 수 있습니다. 그래서 추가적인 연산 필요없이
지금까지 세왔던 이동횟수를 그냥 답으로 적으면 되는거죠.

---

# 코드

```{.cpp}
#include <iostream>
using namespace std;

int main() {
  int T,x,y,d;  //d는 x지점과 y지점 사이의 거리
  cin>>T;
  while(T>0){
    int i=1,cnt=0;  //i는 증감 관련인자, cnt는 이동횟수
    cin>>x>>y;
    d=y-x;
    while(d>i){   //d<=i가 된다면 다음 증감때 남아있는 d(거리)가 0또는 음수가 되므로
                    증감을 실행한 직후에 계속 확인을 해주어야함
      d-=i;     
      cnt++;      
      if(d<=i)
        break;
      d-=i;       //양쪽 끝에서 먼저 이동을 진행
      cnt++;
      i++;        //증감량(이동량)을 
    }
    cout<<++cnt<<'\n';    //마지막 1회를 안셌으므로 ++cnt
    T--;
  }
}
```

---
  
앞으로 열심히 포스팅 올리겠습니다!!
