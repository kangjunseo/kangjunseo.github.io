---
layout: single
title: "<C++> 백준 1978번 소수 찾기 풀이"
---

이번 글에서는 단순히 1978번 풀이 뿐만 아니라 전반적인 소수 탐색 문제들의
전반적인 방향 및 간단한 dp(동적 프로그래밍) 기법의 소개를 해보고자 합니다...!

[백준 1978번](https://www.acmicpc.net/problem/1978)

## DP(동적 프로그래밍)이란...?

사실 저도 학교에서 아직은 알고리즘 수업을 듣지 않은 상태이지만, 백준 문제들을 풀다보니
쓸데 없이 반복되는 과정들을 줄여야만 풀 수 있는 문제들이 있더라고요...! 특히 그것을
느낄 수 있었던 문제는 --> [바로 이 문제](https://www.acmicpc.net/problem/1003) 인데요. 일반적인 피보나치처럼 풀었다가는
바로 `시간 초과`가 뜨게 됩니다.

## 메인 문제로 들어가기 전 간단한 설명(백준 1003번)

```c

#include<stdio.h>
#include<stdlib.h>

int main(){
  int T, N, i = 0;
  int dp[41] = {0, 1, 1};

  for (i = 3; i < 41; i++) dp[i] = dp[i-1] + dp[i-2];

  scanf("%d", &T);

  for (i = 0; i < T; i++) {
    scanf("%d", &N);
    if(N == 0) printf("%d %d\n", 1, 0);
    else if (N == 1) printf("%d %d\n", 0, 1);
    else printf("%d %d\n", dp[N-1], dp[N]);
  }

  return 0;
}

```

앞으로 열심히 포스팅 올리겠습니다!!
