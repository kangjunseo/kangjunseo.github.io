---
layout: single
title: "<C++> 백준 1978번 소수 찾기 풀이"
---

이번 글에서는 단순히 1978번 풀이 뿐만 아니라 전반적인 소수 탐색 문제들의
전반적인 방향 및 간단한 dp(동적 프로그래밍) 기법의 소개를 해보고자 합니다...!

[백준 1978번](https://www.acmicpc.net/problem/1978)

## DP(동적 프로그래밍)이란...?

사실 저도 학교에서 아직은 알고리즘 수업을 듣지 않은 상태이지만, 백준 문제들을 풀다보니
쓸데 없이 반복되는 과정들을 줄여야만 풀 수 있는 문제들이 있더라고요...! 특히 그것을
느낄 수 있었던 문제는 --> [바로 이 문제](https://www.acmicpc.net/problem/1003) 인데요. 일반적인 피보나치처럼 풀었다가는
바로 `시간 초과`가 뜨게 됩니다.

### 메인 문제로 들어가기 전 간단한 설명(백준 1003번)

```c

#include<stdio.h>
#include<stdlib.h>

int main(){
  int T, N, i = 0;
  int dp[41] = {0, 1, 1};  //피보나치 수열의 값을 배열에 저장

  for (i = 3; i < 41; i++) dp[i] = dp[i-1] + dp[i-2]; //미리 저장된 이전 항과 점화식을 연결지어 문제 해결

  scanf("%d", &T);

  for (i = 0; i < T; i++) {
    scanf("%d", &N);
    if(N == 0) printf("%d %d\n", 1, 0);
    else if (N == 1) printf("%d %d\n", 0, 1);
    else printf("%d %d\n", dp[N-1], dp[N]);
  }

  return 0;
}

```

이 문제를 재귀함수라던가 일반적인 `iterative` 형식으로 풀게 된다면 바로 `시간 초과`가 뜨게 되지만,
위의 첫 for 문 `for (i = 3; i < 41; i++) dp[i] = dp[i-1] + dp[i-2];` 처럼 작은 문제의 답을
나중 문제(큰 문제)에 풀 때 활용하는 방식으로 재귀형식에서 반복 호출되는 부분을 대폭 줄일 수 있습니다.

이런 문제풀이 기법이 바로 dp인데요... 설명이 부족하셨을거 같지만,, 아무튼 본 문제로 넘어가겠습니다!

## 백준 1978번 - 사고의 흐름

[]

앞으로 열심히 포스팅 올리겠습니다!!
