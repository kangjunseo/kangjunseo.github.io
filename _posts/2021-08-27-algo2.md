---
layout: single
title: "<C++> 백준 1978번 소수 찾기 풀이"
---

이번 글에서는 단순히 1978번 풀이 뿐만 아니라 전반적인 소수 탐색 문제들의
전반적인 방향 및 간단한 dp(동적 프로그래밍) 기법의 소개를 해보고자 합니다...!

[백준 1978번](https://www.acmicpc.net/problem/1978)

---

## DP(동적 프로그래밍)이란...?

사실 저도 학교에서 아직은 알고리즘 수업을 듣지 않은 상태이지만, 백준 문제들을 풀다보니
쓸데 없이 반복되는 과정들을 줄여야만 풀 수 있는 문제들이 있더라고요...! 특히 그것을
느낄 수 있었던 문제는 --> [바로 이 문제](https://www.acmicpc.net/problem/1003) 인데요. 일반적인 피보나치처럼 풀었다가는
바로 `시간 초과`가 뜨게 됩니다.

![4](/assets/images/4.png)

위 그림을 본다면, 재귀형식의 피보나치가 얼마나 비효율적인지 한 눈에 보실 수 있습니다.. (DP를 사용한다면 한 번 호출한 함수는 다시는
호출하지 않을테니까요!) 

### 메인 문제로 들어가기 전 간단한 설명(백준 1003번)

```c

#include<stdio.h>
#include<stdlib.h>

int main(){
  int T, N, i = 0;
  int dp[41] = {0, 1, 1};  //피보나치 수열의 값을 배열에 저장

  for (i = 3; i < 41; i++) dp[i] = dp[i-1] + dp[i-2]; //미리 저장된 이전 항과 점화식을 연결지어 문제 해결

  scanf("%d", &T);

  for (i = 0; i < T; i++) {
    scanf("%d", &N);
    if(N == 0) printf("%d %d\n", 1, 0);
    else if (N == 1) printf("%d %d\n", 0, 1);
    else printf("%d %d\n", dp[N-1], dp[N]);
  }

  return 0;
}

```

이 문제를 재귀함수라던가 일반적인 `iterative` 형식으로 풀게 된다면 바로 `시간 초과`가 뜨게 되지만,
위의 첫 for 문 `for (i = 3; i < 41; i++) dp[i] = dp[i-1] + dp[i-2];` 처럼 작은 문제의 답을
나중 문제(큰 문제)에 풀 때 활용하는 방식으로 재귀형식에서 반복 호출되는 부분을 대폭 줄일 수 있습니다.

이런 문제풀이 기법이 바로 dp 중에서도 bottom-up 방식인데요... 설명이 부족하셨을거 같지만,, 더 알아보고
싶으신 분들은 [여기](https://namu.wiki/w/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95)를 클릭하셔서 좀 더 자세히 알아보세요!

아무튼 본 문제로 넘어가겠습니다!

---

## 백준 1978번 - 사고의 흐름

![2](/assets/images/3.png)

문제는 매우 간단합니다. N개의 소수를 입력 받고 그 중 소수인 개수들의 합을 출력하면 되는데요, 사실 이문제 자체는
어떤 방법으로 구현하든 N의 최댓값도 100이고, 소수도 1000이하로 주어지고, 시간제한도 무려 2초라서 소수인지 판별하기만
하면 정답처리가 될 것 같습니다. 하지만 저는 좀 더 시간제한이 빡빡한 상위호환 문제들을 풀듯이 한번 풀어보겠습니다.
(이전에 소개드린 dp를 사용해서요!)

## 코드

```cpp

#include <iostream>
using namespace std;

int main() {
  int N,temp,cnt=0,idx=3;
  int prime[1000];  //이 배열에는 소수들을 미리 저장!
  prime[0]=2;
  prime[1]=3;
  prime[2]=5;   //초기 값을 몇 개 설정
  for(int i=6;i<=1000;i++){
    int IsPrime=1;    
    for(int j=0; prime[j]<i/2;j++){ // i의 절반보다 작은 소수들로만 나눠봐도 판별 가능
      if(i%prime[j]==0){    //앞서 구해놓은 소수들로 나눠보기
        IsPrime=0;  // 나누어 떨어지면 소수가 아님!
        break;
      }
    }
    if (IsPrime==1)   //위의 for문을 통과하고도 IsPrime 이 1이라면 소수 
      prime[idx++]=i;
  }

  cin>>N;
  while(N>0){
    cin>>temp;
    cnt++;
    if(temp==1)
      cnt--;
    for(int i=0;prime[i]<=temp/2;i++){
      if(temp%prime[i]==0){
        cnt--;
        break;
      }
    }
    N--;
  }
  cout<<cnt;
}
```


---

앞으로 열심히 포스팅 올리겠습니다!!
